
static int uevent_net_init(struct net *net)
{
    struct uevent_sock *ue_sk;
    struct netlink_kernel_cfg cfg = {
        .groups = 1,
        .flags  = NL_CFG_F_NONROOT_RECV,
    };

    ue_sk = kzalloc(sizeof(*ue_sk), GFP_KERNEL);
    if (!ue_sk)
        return -ENOMEM;

    ue_sk->sk = netlink_kernel_create(net, NETLINK_KOBJECT_UEVENT, &cfg);
    if (!ue_sk->sk) {
        printk(KERN_ERR
               "kobject_uevent: unable to create netlink socket!\n");
        kfree(ue_sk);
        return -ENODEV;
    }
    mutex_lock(&uevent_sock_mutex);
    list_add_tail(&ue_sk->list, &uevent_sock_list);
    mutex_unlock(&uevent_sock_mutex);
    return 0;
}
static void uevent_net_exit(struct net *net)
{
    struct uevent_sock *ue_sk;

    mutex_lock(&uevent_sock_mutex);
    list_for_each_entry(ue_sk, &uevent_sock_list, list) {
        if (sock_net(ue_sk->sk) == net)
            goto found;
    }
    mutex_unlock(&uevent_sock_mutex);
    return;

found:
    list_del(&ue_sk->list);
    mutex_unlock(&uevent_sock_mutex);

    netlink_kernel_release(ue_sk->sk);
    kfree(ue_sk);
}
static struct pernet_operations uevent_net_ops = {
    .init   = uevent_net_init,
    .exit   = uevent_net_exit,
};
static int __init kobject_uevent_init(void)
{
    return register_pernet_subsys(&uevent_net_ops);
}

#define CONFIG_NET
static const char *kobject_actions[] = {
    [KOBJ_ADD] =        "add",
    [KOBJ_REMOVE] =     "remove",
    [KOBJ_CHANGE] =     "change",
    [KOBJ_MOVE] =       "move",
    [KOBJ_ONLINE] =     "online",
    [KOBJ_OFFLINE] =    "offline",
};
int kobject_uevent_env(struct kobject *kobj, enum kobject_action action, char *envp_ext[])
{
	struct kobj_uevent_env *env;
	const char *action_string = kobject_actions[action];
	const char *devpath = NULL;
	const char *subsystem;
	struct kobject *top_kobj;
	struct kset *kset;
	const struct kset_uevent_ops *uevent_ops;
	int i = 0;
	int retval = 0;
    #ifdef CONFIG_NET   // CONFIG_NET表示是否支持网络，一般都是支持的
        struct uevent_sock *ue_sk;
    #endif
	top_kobj = kobj;/* search the kset we belong to */ 
	while(!top_kobj->kset && top_kobj->parent) // 找到距离本kobj血缘最近的kset
		top_kobj = top_kobj->parent;	// 如果本kobj不属于任何的kset，就找父亲的kset
	if (!top_kobj->kset)	// 
		return -EINVAL; // 如果本kobj及其祖宗都没有kset，那么报错返回，由此可说明，如果一个kobject没有加入kset，是不允许上报uevent的
	kset = top_kobj->kset; // kset存在是继续往下走的前提
	uevent_ops = kset->uevent_ops;
	if (kobj->uevent_suppress) // 如果kobj->uevent_suppress为1, 则表示忽略所有上报的uevent事件. 
		return 0; // pr_debug("kobject: '%s' (%p): %s: uevent_suppress caused the event to drop!\n", kobject_name(kobj), kobj, __func__);
	if (uevent_ops && uevent_ops->filter) /* skip the event, if the filter returns zero. */
		if (!uevent_ops->filter(kset, kobj)) // 如果filter()函数执行返回0，则表明跳过本次uevent事件上报
			return 0; // pr_debug("kobject: '%s' (%p): %s: filter function caused the event to drop!\n", kobject_name(kobj), kobj, __func__);
	if (uevent_ops && uevent_ops->name) /* originating subsystem */
		subsystem = uevent_ops->name(kset, kobj);
	else
		subsystem = kobject_name(&kset->kobj);
	if (!subsystem) // 判断所属的kset是否有合法的名称，名字设置不合法，则跳过该事件
		return 0; // pr_debug("kobject: '%s' (%p): %s: unset subsystem caused the event to drop!\n", kobject_name(kobj), kobj, __func__);
	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL); /* environment buffer */
	if (!env)
		return -ENOMEM;
	devpath = kobject_get_path(kobj, GFP_KERNEL); // 找到当前kobj所在的目录
	if (!devpath)
		retval = -ENOENT;
		goto exit;
	retval = add_uevent_var(env, "ACTION=%s", action_string); // 将Action、路径信息、subsystem等信息，添加到env指针中
	if (retval)
		goto exit;
	retval = add_uevent_var(env, "DEVPATH=%s", devpath);
	if (retval)
		goto exit;
	retval = add_uevent_var(env, "SUBSYSTEM=%s", subsystem);
	if (retval)
		goto exit;
	if (envp_ext) /* keys passed in from the caller */
		for (i = 0; envp_ext[i]; i++) 
			retval = add_uevent_var(env, "%s", envp_ext[i]);
			if (retval)
				goto exit;
	if (uevent_ops && uevent_ops->uevent) /* let the kset specific function add its stuff */
		retval = uevent_ops->uevent(kset, kobj, env);
		if (retval)
			goto exit; // pr_debug("kobject: '%s' (%p): %s: uevent() returned %d\n", kobject_name(kobj), kobj, __func__, retval);
	/*
	 * Mark "add" and "remove" events in the object to ensure proper
	 * events to userspace during automatic cleanup. If the object did
	 * send an "add" event, "remove" will automatically generated by
	 * the core, if not already done by the caller.
	 */
	if (action == KOBJ_ADD)
		kobj->state_add_uevent_sent = 1;
	else if (action == KOBJ_REMOVE)
		kobj->state_remove_uevent_sent = 1;
	mutex_lock(&uevent_sock_mutex);
	retval = add_uevent_var(env, "SEQNUM=%llu", (unsigned long long)++uevent_seqnum); /* we will send an event, so request a new sequence number */
	if (retval)
		mutex_unlock(&uevent_sock_mutex);
		goto exit;
	#if defined(CONFIG_NET)
		list_for_each_entry(ue_sk, &uevent_sock_list, list) /* send netlink message */
			struct sock *uevent_sock = ue_sk->sk;
			struct sk_buff *skb;
			size_t len;
			if (!netlink_has_listeners(uevent_sock, 1))
				continue;
			len = strlen(action_string) + strlen(devpath) + 2; /* allocate message with the maximum possible size */
			skb = alloc_skb(len + env->buflen, GFP_KERNEL);
			if (skb)
				char *scratch;
				scratch = skb_put(skb, len); /* add header */
				sprintf(scratch, "%s@%s", action_string, devpath);
				for (i = 0; i < env->envp_idx; i++)	 /* copy keys to our continuous event payload buffer */
					len = strlen(env->envp[i]) + 1;
					scratch = skb_put(skb, len);
					strcpy(scratch, env->envp[i]);
				NETLINK_CB(skb).dst_group = 1;
				retval = netlink_broadcast_filtered(uevent_sock, skb, 0, 1, GFP_KERNEL, kobj_bcast_filter, kobj);
				if (retval == -ENOBUFS || retval == -ESRCH) /* ENOBUFS should be handled in userspace */
					retval = 0;
			else
				retval = -ENOMEM;
	#endif
	mutex_unlock(&uevent_sock_mutex);
	#ifdef CONFIG_UEVENT_HELPER
		if (uevent_helper[0] && !kobj_usermode_filter(kobj)) /* call uevent_helper, usually only enabled during early boot */
			struct subprocess_info *info;
			retval = add_uevent_var(env, "HOME=/");
			if (retval)
				goto exit;
			retval = add_uevent_var(env, "PATH=/sbin:/bin:/usr/sbin:/usr/bin");
			if (retval)
				goto exit;
			retval = init_uevent_argv(env, subsystem);
			if (retval)
				goto exit;
			retval = -ENOMEM;
			info = call_usermodehelper_setup(env->argv[0], env->argv, env->envp, GFP_KERNEL, NULL, cleanup_uevent_env, env);
			if (info)
				retval = call_usermodehelper_exec(info, UMH_NO_WAIT);
				env = NULL;	/* freed by cleanup_uevent_env */
	#endif

	exit:
		kfree(devpath);
		kfree(env);
		return retval;
}
int kobject_uevent(struct kobject *kobj, enum kobject_action action)
{
    return kobject_uevent_env(kobj, action, NULL);
}
int add_uevent_var(struct kobj_uevent_env *env, const char *format, ...) // 添加环境变量
{
    va_list args;
    int len;
    if (env->envp_idx >= ARRAY_SIZE(env->envp))
        return -ENOMEM; // WARN(1, KERN_ERR "add_uevent_var: too many keys\n");
    va_start(args, format);
    len = vsnprintf(&env->buf[env->buflen], sizeof(env->buf) - env->buflen, format, args);
    va_end(args);
    if (len >= (sizeof(env->buf) - env->buflen))
        return -ENOMEM; // WARN(1, KERN_ERR "add_uevent_var: buffer size too small\n");
    env->envp[env->envp_idx++] = &env->buf[env->buflen];
    env->buflen += len + 1;
    return 0;
}
