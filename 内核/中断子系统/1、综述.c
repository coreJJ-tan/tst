1、中断系统相关硬件描述
    中断硬件系统主要有三种器件参与：外设、中断控制器和CPU。
    各个外设提供中断线，在发生中断事件的时候，通过中断线上的电气信号向CPU系统请求处理。
    中断控制器是连接外设终端系统和CPU的桥梁，CPU并不处理中断优先级，那是中断控制器的事情。
    对于CPU而言，一般有两种中断请求，例如：对于ARM，是IRQ和FIQ信号线。

    * GIC 是 ARM 公司给 Cortex-A/R 内核提供的一个中断控制器
    * GIC V1 已经淘汰，GIC V2 是给 ARMv7-A 架构使用的，比如 Cortex-A7、 Cortex-A9、 Cortex-A15 等，V3 和 V4 是给 ARMv8-A/R 架构使用的，也就是 64 位芯片使用的
    * GIC V2 最多支持 8 个核
    * 一个 GIC 最多支持1024个中断源

2、中断控制器和CPU之间的拓扑结构
2.1 GIC 将众多的中断源分为分为三类：
    (1) SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断。比如按键中断、串口中断等等，这些
中断所有的 Core 都可以处理，不限定特定 Core。
    (2) PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就
叫做私有中断。
    (3) SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存器GICD_SGIR 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。

2.2 中断 ID
    GIC V2 最多支持 1020 个中断 ID，中断 ID 号为 ID0~ID1019。这 1020 个 ID 包含了 PPI、 SPI 和 SGI，这 1020 个 ID 分配如下：
    ID0~ID15：这 16 个 ID 分配给 SGI。
    ID16~ID31：这 16 个 ID 分配给 PPI。
    ID32~ID1019：这 988 个 ID 分配给 SPI。

    * Cortex-A7 一共有 8 个中断:
    (1) 复位中断(Rest)， CPU 复位以后就会进入复位中断，我们可以在复位中断服务函数里面做一些初始化工作，比如初始化 SP 指针、 DDR 等等。
    (2) 未定义指令中断(Undefined Instruction)，如果指令不能识别的话就会产生此中断。
    (3) 软中断(Software Interrupt,SWI)，由 SWI 指令引起的中断， Linux 的系统调用会用 SWI指令来引起软中断，通过软中断来陷入到内核空间。
    (4) 指令预取中止中断(Prefetch Abort)，预取指令的出错的时候会产生此中断。
    (5) 数据访问中止中断(Data Abort)，访问数据出错的时候会产生此中断。
    (6) 未使用(Not Used)
    (7) IRQ 中断(IRQ Interrupt)，外部中断，前面已经说了，芯片内部的外设中断都会引起此中断的发生。
    (8) FIQ 中断(FIQ Interrupt)，快速中断，如果需要快速处理中断的话就可以使用此中。
    * Cortex-A 内核 CPU 的所有外部中断都属于 IRQ 中断，当任意一个外部中断发生的时候都会触发 IRQ 中断。IRQ 中断服务函数里面就可以读取指定的寄存器来判断发生的具
体是什么中断，进而根据具体的中断做出相应的处理。

2.3 一个 GIC 控制器和多个 CPU 的硬件拓扑结构
    --中断0(SPI)--       --->                 ---IRQ\FIQ--->         CPU0
    --中断1(SPI)--       --->                 ---IRQ\FIQ--->         CPU1
        ....             --->                ---IRQ\FIQ--->         CPU2
    --中断N(PPI)--       --->    GIC控制器    ---IRQ\FIQ--->         CPU3
    --中断N+1(PPI)--     --->                 ---IRQ\FIQ--->        CPU4
        ....            --->                  ---IRQ\FIQ--->        CPU5
    --中断M(SGI)--      --->                  ---IRQ\FIQ--->        CPU6
    --中断M+1(SGI)--    --->                  ---IRQ\FIQ--->         CPU7

2.4 多个 GIC 控制器和多个 CPU 的硬件拓扑结构
    GIC 控制器是支持多个CPU core的，如果硬件平台中只有一个GIC的话，那么通过控制该GIC的寄存器可以将所有的外设中断，分发给连接在该中断控制器上的CPU。如果有多个GIC呢？
或者级联的中断控制器都支持多个 cpu core？假设我们要设计一个非常复杂的系统，系统中有8个CPU，有2000个外设中断要处理，这时候你如何设计系统中的中断控制器？如果使用GIC的
话，我们需要两个GIC（一个GIC最多支持1024个中断源），一个是root GIC，另外一个是secondary GIC。这时候有两种方案：
    （1）把8个cpu都连接到root GIC上，secondary GIC不接CPU。这时候原本挂接在secondary GIC的外设中断会输出到某个cpu，现在，只能是（通过某个cpu interface的irq signal）
输到root GIC的某个SPI上。对于软件而言，这是一个比较简单的设计，secondary GIC的cpu interface的设定是固定不变的，永远是从一个固定的CPU interface输出到root GIC。这种方
案的坏处是：这时候secondary GIC的PPI和SGI都是没有用的了。此外，在这种设定下，所有连接在secondary GIC上的外设中断要送达的target CPU是统一处理的，要么送去cpu0，要么
cpu 5，不能单独控制。这种方式的拓扑结构如下：

                        CPU0 CPU1     CPU7
                          |   |   ...   |
                              中断控制器0
            -----------------------------------------
            |      |      |        |          |     |
            外设  外设  外设   中断控制器1     外设  外设
                              -----------
                              |         |
                              外设  ... 外设

    （2）当然，你也可以让每个GIC分别连接4个CPU core，root GIC连接CPU0~CPU3，secondary GIC连接CPU4~CPU7。这种状态下，连接在root GIC的中断可以由CPU0~CPU3分担处理，
连接在secondary GIC的中断可以由CPU4~CPU7分担处理。但这样，在中断处理方面看起来就体现不出8核的威力了。这种方式的拓扑结构如下：

                CPU0 CPU1 CPU2 CPU3                  CPU4 CPU5 CPU6 CPU7
                  |    |    |   |                      |    |    |   |
                    中断控制器0                            中断控制器1
            ---------------------------         --------------------------
            |      |            |     |         |      |            |    |
            外设  外设  ...    外设  外设        外设  外设   ...    外设  外设

3、中断控制器把中断事件送给哪个CPU？
    毫无疑问，只有支持多个 cpu core的中断控制器才有这种幸福的烦恼。一般而言，中断控制器可以把中断事件上报给一个CPU或者一组CPU（包括广播到所有的CPU上去）。对于外设类型
的中断，当然是送到一个cpu上就OK了。让硬件处理那么复杂的策略其实是不合理的，复杂的逻辑如果由硬件实现，那么就意味着更多的晶体管，更多的功耗。因此，最普通的做法就是为中断
控制器支持的每一个中断设定一个目标 cpu 的控制接口（当然应该是以寄存器形式出现，对于GIC，这个寄存器就是Interrupt processor target register）。系统有多少个cpu，这个控制
接口就有多少个bits，每个bit代表一个CPU。如果该bit设定为1，那么该中断就上报给该CPU，如果为0，则不上报给该CPU。这样的硬件逻辑比较简单，剩余的控制内容就交给软件好了。例如
如果系统有两个cpu core，某中断想轮流由两个CPU处理。那么当CPU0相应该中断进入中断处理函数的时候，可以将Interrupt processor target register中本CPU对应的bit设定为0，另
外一个CPU的bit设定为1。这样，在下次中断发生的时候，中断控制器就把中断送给了CPU1。对于CPU1而言，在执行该中断的handler的时候，将Interrupt processor target register中
CPU0的bit为设置为1，disable本CPU的比特位，这样在下次中断发生的时候，中断控制器就把中断送给了CPU0。这样软件控制的结果就是实现了特定中断由2个CPU轮流处理的算法。

4、中断子系统相关的软件框架图
|-----------------------------------------------------------------------------------|
|                Driver模块0   Driver模块1  ...  Driver模块N                         |  驱动层相关代码
|-----------------------------------------------------------------------------------|
|-----------------------------------------------------------------------------------|
|                   Linux Kernel通用中断处理模块                                     |  硬件无关代码层
|-----------------------------------------------------------------------------------|
|-----------------------------------------------------------------------------------|
|    CPU Architecture related code 0 ... CPU Architecture related code N            |  CPU体系结构层
|-----------------------------------------------------------------------------------|
|-----------------------------------------------------------------------------------|
|               Interrupt Controller 0 ... Interrupt Controller  N                  |  中断控制器层
|-----------------------------------------------------------------------------------|

linux kernel的中断子系统分成4个部分：
    （1）Interrupt controller驱动代码 。和系统使用的Interrupt controller相关。
    （2）CPU architecture相关的中断处理。 和系统使用的具体的CPU architecture相关。
    （3）硬件无关的代码，我们称之Linux kernel通用中断处理模块。无论是哪种CPU，哪种controller，其中断处理的过程都有一些相同的内容，这些相同的内容被抽象出来，和HW无关。
此外，各个外设的驱动代码中，也希望能用一个统一的接口实现irq相关的管理（不和具体的中断硬件系统以及CPU体系结构相关）这些“通用”的代码组成了linux kernel interrupt subsystem
的核心部分。
    （4）普通外设的驱动。这些驱动将使用Linux kernel通用中断处理模块的API来实现自己的驱动逻辑。

5、更多的思考
    （1）中断控制器发送给CPU的中断是否可以收回？重新分发给另外一个CPU？
    （2）系统中的中断如何分发才能获得更好的性能呢？
    （3）中断分发的策略需要考虑哪些因素呢？
