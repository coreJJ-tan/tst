// ioremap() 函数====================================================================================================
一些基础概念:
    几乎每一种外设都是通过读写设备上的相关寄存器来进行的, 通常包括控制寄存器、状态寄存器和数据寄存器三大类, 外设的寄存器通常被连续地编址。根据CPU体系结构的不同, CPU对IO端口的编址方式有两种:
    a - I/O 映射方式(I/O-mapped)
        典型地, 如X86处理器为外设专门实现了一个单独的地址空间, 称为"I/O地址空间"或者"I/O端口空间", CPU通过专门的I/O指令(如X86的IN和OUT指令)来访问这一空间中的地址单元。
    b - 内存映射方式(Memory-mapped)
         RISC指令系统的CPU(如ARM、PowerPC等)通常只实现一个物理地址空间, 外设I/O端口成为内存的一部分。 此时, CPU可以象访问一个内存单元那样访问外设I/O端口, 而不需要设立专门的外设I/O指令。

    但是, 这两者在硬件实现上的差异对于软件来说是完全透明的, 驱动程序开发人员可以将内存映射方式的I/O端口和外设内存统一看作是"I/O内存"资源。
    一般来说, 在系统运行时, 外设的I/O内存资源的物理地址是已知的, 由硬件的设计决定。但是CPU通常并没有为这些已知的外设I/O内存资源的物理地址预定义虚拟地址范围, 驱动程序并不能直接通过物理地址
访问I/O内存资源, 而必须将它们映射到核心虚地址空间内(通过页表), 然后才能根据映射所得到的核心虚地址范围, 通过访内存指令访问这些I/O内存资源。
    Linux在io.h头文件中声明了函数ioremap(), 用来将I/O内存资源的物理地址映射到核心虚地址空间(3GB-4GB)中(这里是内核空间), 原型如下:
    ioremap宏定义在asm/io.h内:
        #define ioremap(cookie,size)   __ioremap(cookie,size,0)
    __ioremap函数原型为(arm/mm/ioremap.c):
        void __iomem * __ioremap(unsigned long phys_addr, size_t size, unsigned long flags);
    参数:
        phys_addr:要映射的起始的IO地址
        size:要映射的空间的大小
        flags:要映射的IO空间和权限有关的标志
        该函数返回映射后的内核虚拟地址(3G-4G). 接着便可以通过读写该返回的内核虚拟地址去访问之这段I/O内存资源。
        返回值： __iomem 类型的指针，指向映射后的虚拟空间首地址。

// iounmap() 函数====================================================================================================
    iounmap函数用于取消ioremap（）所做的映射，原型如下：
        void iounmap(void * addr);

// writeb()、writew()、writel()函数====================================================================================================
    void writeb(u8 value, volatile void __iomem *addr)
    void writew(u16 value, volatile void __iomem *addr)
    void writel(u32 value, volatile void __iomem *addr)
    writeb、 writew 和 writel 这三个函数分别对应 8bit、 16bit 和 32bit 写操作，参数 value 是要写入的数值， addr 是要写入的地址。

// readb()、readw()、readl()函数====================================================================================================
    u8 readb(const volatile void __iomem *addr)
    u16 readw(const volatile void __iomem *addr)
    u32 readl(const volatile void __iomem *addr)
    readb、 readw 和 readl 这三个函数分别对应 8bit、 16bit 和 32bit 读操作，参数 addr 就是要读取写内存地址，返回值就是读取到的数据

// copy_to_user()函数====================================================================================================
    功能：从内核空间复制数据到用户空间
    unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
    如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。
    *to是用户空间的指针，
    *from是内核空间指针，
    n表示从内核空间向用户空间拷贝数据的字节数

// copy_from_user()函数====================================================================================================
    功能：用于将用户空间的数据传送到内核空间。
    unsigned long copy_from_user(void * to, const void __user * from, unsigned long n)
    第一个参数to是内核空间的数据目标地址指针，
    第二个参数from是用户空间的数据源地址指针，
    第三个参数n是数据的长度。
    如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。
    此函数将from指针指向的用户空间地址开始的连续n个字节的数据产送到to指针指向的内核空间地址

// dump_stack()函数====================================================================================================
    linux内核提供函数dump_stack()来跟踪函数的调用过程，原理是通过打印当前cpu的堆栈的调用函数来显示当前的上下文环境与调用关系；
    但是，使用dump_stack有不足之处
    dump_stack的原理是遍历堆栈，把所有可能是内核函数的内容找出来，并打印对应的函数。因为函数调用时会把下一条指令的地址放到堆栈中。所以只要找到这些return address，就可以找到
这些return address所在函数，进而打印函数的调用关系。
    使用dump_stack可能不准确，可能的原因有三：
    1.所有这些可以找到的函数地址，存在/proc/kallsyms中。它并不包括内核中所有的函数，而只包括内核中stextetext和sinittexteinittext范围的函数，及模块中的函数。详细可参考
scripts/kallsyms.c
    2.一些函数在编译时进行了优化，把call指令优化为jmp指令，这样在调用时就不会把return address放到堆栈，导致dump_stack时在堆栈中找不到对应的信息。
    3.堆栈中可能有一些数值，它们不是return address，但是在内核函数地址的范围里，这些数值会被误认为return address从而打印出错误的调用关系。
// vsnprintf()函数====================================================================================================
	int vsnprintf (char * s, size_t n, const char * format, va_list arg );
	将格式化后的字符串存到s内存地址处，最多保存的字符串字节数为n-1，如果格式化字符串长度大于n-1，则多出的部分被丢弃。
	返回值是保存的字符串的字节数，返回值为负数，则表明格式字符串解析失败。
// kzalloc()、kmalloc()函数====================================================================================================
	kzalloc( )函数与kmalloc( )函数功能类似，都是基于slab分配在物理上连续的实际的内存。但是kzalloc( )函数在分配了内存之后，又将内存中的内容都初始化为0。
	static __always_inline void *kmalloc(size_t size, gfp_t f lags)
		分配在物理上连续的内存，虚拟地址自然也是连续的，它基于slab分配实际上存在的连续的内存。
		size：是指要分配的内存的字节数。
		flags：是分配标志，它提供了多种kmalloc( )的行为。其中分配标志（flags）的常见取值参考alloc_pages( )函数的分析
	
	
	static inline void *kzalloc(size_t size, gfp_t flags)
		size：指要分配的内存的字节数。
		flags：分配标志，它提供了多种kzalloc( )的行为，其选项取值参考kmalloc( )函数的分析。
		返回值：该内存对象的起始地址
	
// BUG_ON()与WARN_ON()====================================================================================================
linux 内核态调试函数BUG_ON()与WARN_ON()
https://blog.csdn.net/xiaohua0877/article/details/78515472
// copy_from_user()函数====================================================================================================
snprintf
// copy_from_user()函数====================================================================================================
kmalloc
kfree
// copy_from_user()函数====================================================================================================
container_of
// copy_from_user()函数====================================================================================================
kstrtol———变换一个字符串为long 型
// copy_from_user()函数====================================================================================================
restart_syscall
// copy_from_user()函数====================================================================================================
ACCESS_ONCE
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
