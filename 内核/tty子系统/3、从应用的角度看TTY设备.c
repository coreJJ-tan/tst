http://www.wowotech.net/tty_framework/application_view.html
1、再谈终端（Terminal）设备
1.1 终端的类型
(1) 控制台终端（console）
    这类终端的输入设备通常是键盘，输出设备通常是显示器；
    输入、输出设备通过各类总线直接和计算机相连；
    “终端”其实是这些设备的一个逻辑抽象。

(2) 虚拟终端（VT）
    控制台终端的输出设备（显示器）一般只有一个，同一时刻由一个应用程序独占；但在多任务的操作环境中，有时需要在将终端切换给另一个应用程序之前，
保留当前应用在终端上的输出，以方便后面查看；因此Unix/Linux系统在控制台终端的基础上，又虚拟出来6个终端----称作虚拟终端，不同的应用程序可以在
这些虚拟终端上独立的输出，在需要的时候，可以通过键盘的组合键（CTRL+ALT+ F1~F6）将某一个虚拟终端调出来在屏幕上显示。

(3) 串口终端（TTY）
    输入设备和输出设备集成在一个独立的硬件上（称作TTY设备），这个硬件和计算机通过串口连接；
    输入设备（键盘）的输入动作，将会转换为串口上的RX数据包（以计算机为视角），发送给计算机；
    计算机的输出会以TX数据包的形式发送给TTY设备，TTY设备转换后在输出设备（屏幕）上显示。

(4) 软件终端
    这是我们现在最常用的终端：
    户的输入并打包通过串口发送给计算机，以及接收计算机从串口发来的输出并显示出来，任何设备都可以变成终端设备，例如另一台计算机；
    当另一台计算机被当作终端设备时，通常不会把它的所有资源都用来和对端进行人机交互，常用的方法是，在这个计算机上利用软件，模拟出来一个“终端设备”。
该软件就像一个中间商：从键盘接收用户输入，然后控制串口发送给对端；从串口接收对端的输出，然后在软件界面上显示出来；
    平时大家经常使用的PuTTY、SecureCRT、Windows超级终端、等等，都是“软件终端”。

(5) USB、网络等终端
    既然串口可以作为人机交互数据的传说媒介，其它通信接口一样可以，例如USB、Ethernet、等等，其原理和串口终端完全一样，这里不再过多说明。

(6) 图形终端
    前面所介绍的那些终端，人机交互的输出界面都是字符界面，随着计算机技术的发展，GUI界面慢慢出现并成为主流，这些通过GUI交互的形式，也可以称作图
形终端。不过这已经超出了TTY framework系列文章的讨论范围了，因为TTY的势力范围只涵盖字符界面。

2、软件视角
2.1 console driver
    Linux系统中可以存在多个种类各异的终端设备，工程师会使用一个个的TTY driver（struct tty_driver）驱动它们。如果某些我们需要让某些终端作为控
制台终端，可以基于TTY driver，创建对应的console driver，并注册给kernel。
    关于console driver，kernel有如下的策略：
    1）可以同时注册多个console driver，并有选择的使用。
    2）可以在kernel启动的时候，通过命令行（或者后来的device tree），告诉kernel使用哪个或者哪些控制台终端。例如：
        console=”/dev/ttyS0”, console=”/dev/ttyUSB0”
    3）对kernel的日志输出来说，可以在所有被选中的控制台终端上输出。
    4）后续可用作人机交互的控制台终端只能有一个（后指定的那个）。

2.2 控制台终端（/dev/console）
    控制台终端只能有一个（最后指定的那个），那么“/dev/console”又是怎么回事呢？
    kernel启动的后期，会在kernel_init线程（最后会退化为init进程）中打开控制台终端。控制台终端的类型、名称是五花八门的，怎么让kernel的核心代码
无视这些差异呢？这就是“/dev/console”的存在意义：
    /dev/console的设备号固定为(5, 1) ，当init线程打开该设备的时候，TTY core会问system console core：喂，哪一个终端适合做控制台终端啊？因此，
最终打开的是那个具体的、可以当作控制台终端的设备，而“/dev/console”，仅仅是一个占位坑，如下图所示：
                                            ----------------
                                            |   Process A  |
                                            |_______|______|
                                                    |
                                            --------|-------
                                            | /dev/console |
                                            |_______|______|
                                        ____________|________________
                                       |            |                |
                                       |            |                |
                                -------|-----   ----|---------    ---|---
                                | /dev/ttyS0 |  | /dev/tty0  |    | ... |
                                |____________|  |____________|    |_____|

2.3 虚拟终端（/dev/ttyN）
    正如其名，虚拟终端是虚拟出来的一个终端，不对应具体的设备（屏幕和键盘）。应用程序可以打开某一个虚拟终端，以便和人进行交互。
    对应用程序而言，这个终端和具体的物理终端，没有任何区别（应用程序也无法区分）。而对整个系统来说，由于物理资源（键盘和屏幕）只有一套，因此同
一时刻只能和某一个虚拟终端对接。从另一个角度看，各个虚拟终端轮流使用物理资源和人进行交互，如下所示：
        -----------------   -----------------   -----------------   -----------------
        | Application A |   | Application B |   | Application C |   | Application N |
        |_______|_______|   |________|______|   |_______|_______|   |_______|_______|
                |                    |                  |                   |
           _____|_____          _____|_____        _____|_____           ___|___
          | /dev/tty0 |        | /dev/tty1 |      | /dev/tty2 |         |  ...  |
          |_____|_____|        |_____|_____|      |_____|_____|         |___|___|
                |                    |                  |                   |
                -------------------------------------------------------------
                                               |
                                        _______|_______
                                        | /dev/console|
                                        |_____________|

2.4 伪终端(Pseudo Terminal，pty)
    前面提到过，既然串口（serial）可用作终端和计算机之间的数据传输通道，那么其它诸如Ethernet的通信介质，也可以实现类似的功能。但这里面有一个问
题（以网络为例）：
    Linux系统中的网络驱动，并不是以TTY的形式提供API（众所周知，网络使用socket接口）。因此，系统中的应用程序想要和对应的终端设备通信，但是无法
直接打开网络设备，怎么办？
    解决方案就是伪终端（英文为Pseudo Terminal，简称pty）。字面上理解，伪终端根本不是终端（虚拟终端好歹还是），是为了让应用程序可以从网络等非串
口类的接口上，和终端设备交互而伪造出来的一种东西。它的原理如下：
    pty 由 pts(pseudo-terminal slave) 和 ptm(pseudo-terminal master) 两部分组成。
    pts 伪造出一个标准的 TTY 设备，应用程序可以直接访问。应用程序向pts写入的数据，会直接反映到 ptm 上，同样，应用程序从 pts 读数据，则相当于直
接从 ptm 读取。而 ptm，则根据具体情况，具体实现。例如：要通过网络接口和终端设备交互，则 ptm 需要打开对应的 socket，将 pts 写来的数据，从 socket
送出，将从 socket 读取的数据，送回给pts。
    有了伪终端，Unix/Linux系统中的终端设备就可以脱离具体的物理限制，可以是任何形态，例如在GUI环境中，使用Terminal软件（如xterm）模拟出来的终
端，其原理为：
    用户启动 xterm 等 Terminal 软件的时候，该软件会生成一对 pts 和 ptm，同时执行 shell 应用；Terminal 软件会将 pts 交给 shell 应用，shell 应
用傻傻分不清，还以为它是一个标准的 TTY 设备呢，欢快的运行了； shell 从 pts 读入数据，相当于从 ptm 读入；shell 向 pts 输出数据，相当于向 ptm 写入；
这是由 TTY framework 自动完成的，不需要 Terminal 软件关心；在另一端，Terminal 软件将会从 ptm 读取数据（实际上是 shell 通过 pts 写入的数据），并
显示在自己的 GUI 窗口上；于此同时，Terminal 软件会从自己的 GUI 窗口接收用户输入，并通过 pts 转给 shell，太完美了。
    上面提到了有关伪终端的两个例子，其示意图图下：
                               _______________
                              |   Process     |
                              | (shell, etc.) |
                              |_______|_______|
                                      |
                                  ____|____        ________
                                |   pts    |______|  ptm   |
                                |__________|      |___|____|
                                                      |
                                             _________|__________
                                            |      Terminal      |
                                            | (sshd, xtem, etc.) |
                                            |____________________|
    ---- 提示：Linux Shell 是⼀个⽤ C 语⾔编写的程序,它是⽤户使⽤ Linux 的桥梁。注意，它是一个程序。 参考 https://www.linuxprobe.com/shell-process.html

2.5 控制终端（control terminal，/dev/tty）
    讲到控制终端（control terminal），就不得不提 Unix/Linux 的 Job control 功能。有关 job control，感兴趣的读者可以参考其它文章，这里简单总结如下：
    1）job control 是 Unix/Linux shell（记住，shell是一个应用程序）中的概念，是 shell 用来管理、控制 jobs 的一种方法。
    2）job 是进程组（process group[4]）在 shell 中的体现。换句话说，shell 借用进程组实现了 job。
    3）进程组（或者 job，在本文中可以等同，后面不在区分）是多个进程的组合。

    基于上面简单的知识（不一定准确，但不影响我们对控制终端的理解），我们引入控制终端的概念：

    1）通常情况下，Linux 启动后，终端（以后都用 TTY 指代）的控制权会交给 shell（一种应用程序）。所谓的控制权，就是指 shell 程序可以通过 TTY 读取终
端的输入，以及通过 TTY 向终端输出。
    2）通过 shell，可以启动其它的应用程序，相应地，应用程序在需要的时候也会获得 TTY 的控制权。
    3）同一时刻，只能有一个应用可以占有 TTY，即只有一个应用可以通过 TTY 输入、输出。
    4）那个占有 TTY、可以进行输入输出的应用，称作前台应用。相应的，不能进行输入输出的应用，称作后台应用。因此，shell 中只有一个前台应用，可以有多个
后台应用。
    5）然后，问题就来了：如果某个后台应用，就是想输入输出，怎么办？有一个办法，就是通过控制终端（control terminal）。
    6）控制终端在 Linux 中的名称固定为 /dev/tty, 设备号为(5, 0)，作用和 /dev/console 类似，进程可以通过 TTY core 提供的 ioctl，选择控制终端所对
应的实际的终端设备。
    7）暂且抛开前台应用不谈（因为人家有 TTY 设备），对于那些后台应用，如果想输入输出，可以读取或者写入控制终端。此时，一般情况下，TTY core 会向后台
应用发送 SIGTTIN(读取控制终端时) 或者 SIGTTOU（写入控制终端时）信号，这会终止该后台应用。
    8）不过，shell 会重设收到 SIGTTOU 信号时的行为，于是，后台应用写入的内容，可以通过控制终端显示出来。