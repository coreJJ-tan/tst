// ioremap() 函数====================================================================================================
一些基础概念:
    几乎每一种外设都是通过读写设备上的相关寄存器来进行的, 通常包括控制寄存器、状态寄存器和数据寄存器三大类, 外设的寄存器通常被连续地编址。根据CPU体系结构的不同, CPU对IO端口的编址方式有两种:
    a - I/O 映射方式(I/O-mapped)
        典型地, 如X86处理器为外设专门实现了一个单独的地址空间, 称为"I/O地址空间"或者"I/O端口空间", CPU通过专门的I/O指令(如X86的IN和OUT指令)来访问这一空间中的地址单元。
    b - 内存映射方式(Memory-mapped)
         RISC指令系统的CPU(如ARM、PowerPC等)通常只实现一个物理地址空间, 外设I/O端口成为内存的一部分。 此时, CPU可以象访问一个内存单元那样访问外设I/O端口, 而不需要设立专门的外设I/O指令。

    但是, 这两者在硬件实现上的差异对于软件来说是完全透明的, 驱动程序开发人员可以将内存映射方式的I/O端口和外设内存统一看作是"I/O内存"资源。
    一般来说, 在系统运行时, 外设的I/O内存资源的物理地址是已知的, 由硬件的设计决定。但是CPU通常并没有为这些已知的外设I/O内存资源的物理地址预定义虚拟地址范围, 驱动程序并不能直接通过物理地址
访问I/O内存资源, 而必须将它们映射到核心虚地址空间内(通过页表), 然后才能根据映射所得到的核心虚地址范围, 通过访内存指令访问这些I/O内存资源。
    Linux在io.h头文件中声明了函数ioremap(), 用来将I/O内存资源的物理地址映射到核心虚地址空间(3GB-4GB)中(这里是内核空间), 原型如下:
    ioremap宏定义在asm/io.h内:
        #define ioremap(cookie,size)   __ioremap(cookie,size,0)
    __ioremap函数原型为(arm/mm/ioremap.c):
        void __iomem * __ioremap(unsigned long phys_addr, size_t size, unsigned long flags);
    参数:
        phys_addr:要映射的起始的IO地址
        size:要映射的空间的大小
        flags:要映射的IO空间和权限有关的标志
        该函数返回映射后的内核虚拟地址(3G-4G). 接着便可以通过读写该返回的内核虚拟地址去访问之这段I/O内存资源。
        返回值： __iomem 类型的指针，指向映射后的虚拟空间首地址。

// iounmap() 函数====================================================================================================
    iounmap函数用于取消ioremap（）所做的映射，原型如下：
        void iounmap(void * addr);

// writeb()、writew()、writel()函数====================================================================================================
    void writeb(u8 value, volatile void __iomem *addr)
    void writew(u16 value, volatile void __iomem *addr)
    void writel(u32 value, volatile void __iomem *addr)
    writeb、 writew 和 writel 这三个函数分别对应 8bit、 16bit 和 32bit 写操作，参数 value 是要写入的数值， addr 是要写入的地址。

// readb()、readw()、readl()函数====================================================================================================
    u8 readb(const volatile void __iomem *addr)
    u16 readw(const volatile void __iomem *addr)
    u32 readl(const volatile void __iomem *addr)
    readb、 readw 和 readl 这三个函数分别对应 8bit、 16bit 和 32bit 读操作，参数 addr 就是要读取写内存地址，返回值就是读取到的数据

// copy_to_user()函数====================================================================================================
    功能：从内核空间复制数据到用户空间
    unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
    如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。
    *to是用户空间的指针，
    *from是内核空间指针，
    n表示从内核空间向用户空间拷贝数据的字节数

// copy_from_user()函数====================================================================================================
    功能：用于将用户空间的数据传送到内核空间。
    unsigned long copy_from_user(void * to, const void __user * from, unsigned long n)
    第一个参数to是内核空间的数据目标地址指针，
    第二个参数from是用户空间的数据源地址指针，
    第三个参数n是数据的长度。
    如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数。
    此函数将from指针指向的用户空间地址开始的连续n个字节的数据产送到to指针指向的内核空间地址
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
// copy_from_user()函数====================================================================================================
